{"version":3,"file":"static/js/514.2190d19f.chunk.js","mappings":"gRACA,EAAuB,wBAAvB,EAAuD,yB,SCS1CA,EAAY,WAEvB,IAAMC,GAAWC,EAAAA,EAAAA,MAGjB,GAAkCC,EAAAA,EAAAA,UAAS,IAA3C,eAAOC,EAAP,KAAkBC,EAAlB,KACA,GAAwCF,EAAAA,EAAAA,UAAS,IAAjD,eAAOG,EAAP,KAAqBC,EAArB,KAGMC,EAAW,SAAC,GAAiC,IAAD,IAA9BC,OAAUC,EAAoB,EAApBA,KAAMC,EAAc,EAAdA,MACrB,UAATD,EACFL,EAAaM,GAEbJ,EAAgBI,EAEnB,EAEKC,EAAY,mCAAG,WAAMC,GAAN,oEACnBA,EAAEC,iBAEGV,GAAcE,EAHA,uBAKjBS,IAAAA,OAAAA,QAAA,8JALiB,0BAUnBd,GACEe,EAAAA,EAAAA,IAAW,CACTC,MAAOb,EACPc,SAAUZ,KAGXa,SACAC,MAAK,SAAAC,GACJC,QAAQC,IAAI,2BAA4BF,EAAQG,KAAKd,MACrDK,IAAAA,OAAAA,QAAA,iGAA4CM,EAAQG,KAAKd,KAAzD,KAKD,IACAe,OAAM,SAAAC,GACLX,IAAAA,OAAAA,QAAA,sDACcW,EADd,4MAGD,IA7BgB,2CAAH,sDAgClB,OACE,kBAAMC,UAAWC,EAAUC,SAAUjB,EAAckB,aAAa,MAAhE,WACE,mBAAOH,UAAWC,EAAlB,mBAEE,kBACED,UAAU,oBAEVI,YAAY,SACZ,aAAW,SACXC,KAAK,QACLtB,KAAK,QACLuB,SAAUzB,EACVG,MAAOP,QAGX,mBAAOuB,UAAWC,EAAlB,sBAEE,kBACED,UAAU,oBAEVI,YAAY,SACZ,aAAW,SACXC,KAAK,WACLtB,KAAK,WACLuB,SAAUzB,EACVG,MAAOL,QAGX,mBAAQ0B,KAAK,SAASL,UAAU,0BAAhC,sBAKL,ECnFD,EARc,WACZ,OACE,0BACE,SAAC3B,EAAD,KAGL,C","sources":["webpack://react-homework-template/./src/components/LoginForm/LoginForm.module.css?4ac5","components/LoginForm/LoginForm.jsx","pages/Login/LoginPage.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"form\":\"LoginForm_form__gPEx5\",\"label\":\"LoginForm_label__F7sLE\",\"container\":\"LoginForm_container__YDFcb\",\"title\":\"LoginForm_title__5FilZ\"};","import Notiflix from 'notiflix';\n\nimport { useState } from 'react';\nimport { useDispatch } from 'react-redux';\n// import { useNavigate } from 'react-router-dom';\n\nimport { fetchLogIn } from 'redux/auth/fetchAuth';\n// import { selectIsLoggedIn } from 'redux/auth/selectors';\nimport css from './LoginForm.module.css';\n\nexport const LoginForm = () => {\n  // const navigate = useNavigate();\n  const dispatch = useDispatch();\n  // const isLogged = useSelector(selectIsLoggedIn);\n\n  const [userEmail, setUserEmail] = useState('');\n  const [userPassword, setUserPassword] = useState('');\n\n  // Записую дані полів інпут у відповідні стейти\n  const getInput = ({ target: { name, value } }) => {\n    if (name === 'email') {\n      setUserEmail(value);\n    } else {\n      setUserPassword(value);\n    }\n  };\n\n  const handleSubmit = async e => {\n    e.preventDefault();\n    // const form = e.currentTarget;\n    if (!userEmail || !userPassword) {\n      // alert(`Всі поля мають бути заповнені`);\n      Notiflix.Notify.failure(`Всі поля мають бути заповнені`);\n      return;\n    }\n\n    // const isLogged =\n    dispatch(\n      fetchLogIn({\n        email: userEmail,\n        password: userPassword,\n      })\n    )\n      .unwrap()\n      .then(promise => {\n        console.log('handleSubmit >> promise:', promise.user.name);\n        Notiflix.Notify.success(`Ласкаво просимо, ${promise.user.name}.`);\n        // Можна і не чистити поля, бо все одно переходимо на іншу сторінку:\n        // setUserEmail('');\n        // setUserPassword('');\n        //   // navigate('/profile', { replace: true });\n      })\n      .catch(error => {\n        Notiflix.Notify.failure(\n          `Помилка: ${error}. Можливо не правильний логін чи пароль.`\n        );\n      });\n  };\n\n  return (\n    <form className={css.form} onSubmit={handleSubmit} autoComplete=\"off\">\n      <label className={css.label}>\n        Email\n        <input\n          className=\"form-control me-2\"\n          // type=\"search\"\n          placeholder=\"Search\"\n          aria-label=\"Search\"\n          type=\"email\"\n          name=\"email\"\n          onChange={getInput}\n          value={userEmail}\n        />\n      </label>\n      <label className={css.label}>\n        Password\n        <input\n          className=\"form-control me-2\"\n          // type=\"search\"\n          placeholder=\"Search\"\n          aria-label=\"Search\"\n          type=\"password\"\n          name=\"password\"\n          onChange={getInput}\n          value={userPassword}\n        />\n      </label>\n      <button type=\"submit\" className=\"btn btn-outline-primary\">\n        Log In\n      </button>\n    </form>\n  );\n};\n","import { LoginForm } from 'components/LoginForm/LoginForm';\nconst Login = () => {\n  return (\n    <div>\n      <LoginForm />\n    </div>\n  );\n};\n\nexport default Login;\n\n// import { useNavigate } from 'react-router-dom';\n\n// export const Login = () => {\n//   const navigate = useNavigate();\n\n//   const handleSubmit = async values => {\n//     const response = await FakeAPI.login(values);\n//     if (response.success) {\n//       navigate('/profile', { replace: true });\n//     }\n//   };\n// // Другий, необов'язковий аргумент функції navigate (об'єкт параметрів) має властивість replace (за замовчуванням false), яка контролює як буде додано новий запис на стек історії. За замовчуванням буде звичайний стек. Якщо вказати значення true, то новий запис підмінить собою найвищий. Це використовується досить рідко, наприклад при логіні, щоб користувач не зміг повернутися кнопкою «назад» на сторінку логіна після входу, адже він уже в системі і робити йому там нічого.\n//   return (\n//     <div>\n//       <h1>Login page</h1>\n//       <LoginForm onSubmit={handleSubmit} />\n//     </div>\n//   );\n// };\n"],"names":["LoginForm","dispatch","useDispatch","useState","userEmail","setUserEmail","userPassword","setUserPassword","getInput","target","name","value","handleSubmit","e","preventDefault","Notiflix","fetchLogIn","email","password","unwrap","then","promise","console","log","user","catch","error","className","css","onSubmit","autoComplete","placeholder","type","onChange"],"sourceRoot":""}